#if (${PACKAGE_NAME} && ${PACKAGE_NAME} != "")package ${PACKAGE_NAME};#end
#parse("File Header.java")
import java.util.*;
import java.util.stream.*;
import java.io.*;
import java.lang.*;
import java.text.*;
import org.jetbrains.annotations.*;

public class ${NAME} {
    public static void main(String[] args) throws IOException {
        String fileName = "${NAME}".toLowerCase() + ".dat";
        Scanner scan = new Scanner(new File(fileName));

        int lines = scan.nextInt(); scan.nextLine();

        for (int i = 0; i < lines; i++) {

        }

    }
}

private static final String SYMBOLS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

public static String toInputBase(int inputNum, int base) {
    String s = "";
    while (inputNum > 0) {
        s += SYMBOLS.charAt(inputNum % base);
        inputNum /= base;
    }
    StringBuilder ix = new StringBuilder();
    ix.append(s);
    return new String(ix.reverse());
}

public static int hammingDistance(long n1, long n2) {
        long l = Long.parseLong("" + BigInteger.valueOf(n1).xor(BigInteger.valueOf(n2)));
        int setBits = 0;

        while (l > 0) {
            setBits += l & 1;
            l >>= 1;
        }

        return setBits;
    }

class Point implements Comparable<Point> {
    int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int compareTo(@NotNull Point p) {
        if (this.x == p.x)
            return this.y - p.y;
        else
            return this.x - p.x;
    }

}

public class ConvexHull {

    public static long cross(Point O, Point A, Point B) {
        return (A.x - O.x) * (long) (B.y - O.y) - (A.y - O.y) * (long) (B.x - O.x);
    }
    public static Point[] convex_hull(Point[] P) {
        if (P.length > 1) {
            int n = P.length, k = 0;
            Point[] H = new Point[2 * n];
            Arrays.sort(P);
            for (Point point : P) {
                while (k >= 2 && cross(H[k - 2], H[k - 1], point) <= 0)
                    k--;
                H[k++] = point;
            }
            for (int i = n - 2, t = k + 1; i >= 0; i--) {
                while (k >= t && cross(H[k - 2], H[k - 1], P[i]) <= 0)
                    k--;
                H[k++] = P[i];
            }
            if (k > 1)
                H = Arrays.copyOfRange(H, 0, k - 1);
            return H;
        } else
            return P;
    }

    # Implementation
    #public static void main(String[] args) throws IOException {
    #    Scanner scan = new Scanner(new File("LongString.dat"));
    #    int size = scan.nextInt() + 1;
    #    Point[] p = new Point[size];
    #    for (int i = 0; i < p.length; i++)
    #        p[i] = new Point(scan.nextInt(), scan.nextInt()) ;
    #    Point[] hull = convex_hull(p).clone();
    #    ArrayList<Point> points = new ArrayList<>();
    #    for (Point point : hull)
    #        if (point != null)
    #            points.add(point);
    #    System.out.printf("%.2f", findStringLength(points));
    #}
    public static double findStringLength(ArrayList<Point> arr) {
        double sum = 0.0;
        for (int i = 0; i < arr.size() - 1; )
            sum += distance(arr.get(i), arr.get(++i));
        return sum + distance(arr.get(0), arr.get((arr.size()) - 1));
    }
    public static double distance(Point one, Point two) {
        return Math.sqrt(Math.pow((one.x - two.x), 2) + Math.pow((one.y - two.y), 2));
    }
}

public static double distance(int x1, int x2, int y1, int y2) {
     return Math.sqrt(Math.pow((y2 - y1), 2) + Math.pow(x2-x1, 2));
}

public static int mode(ArrayList<String> array) {
    HashMap<String,Integer> hm = new HashMap<String,Integer>();
    int max  = 1;
    String temp = "";

    for(int i = 0; i < array.size(); i++) {

        if (hm.get(array.get(i)) != null) {

            int count = hm.get(array.get(i));
            count++;
            hm.put(array.get(i), count);

            if(count > max) {
                max  = count;
                temp = array.get(i);
            }
        }

        else
            hm.put(array.get(i),1);
    }
    return Integer.parseInt(temp);
}

public static long LCM(ArrayList<Integer> arr) {
    long lcm = 1;
    int divisor = 2;

    while (true) {
        int counter = 0;
        boolean divisible = false;

        for (int i = 0; i < arr.size(); i++) {
            if (arr.get(i) == 0)
                return 0;
            else if (arr.get(i) < 0)
                arr.set(i, arr.get(i) * -1);
            if (arr.get(i) == 1)
                counter++;
            if (arr.get(i) % divisor == 0) {
                divisible = true;
                arr.set(i, arr.get(i) / divisor);
            }
        }
        if (divisible)
            lcm *= divisor;
        else
            divisor++;
        if (counter == arr.size())
            return lcm;
    }
}

public static Integer[] toIntegerArr(int[] arr) {
    Integer[] ret = new Integer[arr.length];
    for (int i = 0; i < arr.length; i++) {
        ret[i] = arr[i];
    }
    return ret;
}

public static void main(String[] args) throws Throwable {
    Scanner scan = new Scanner(new File("blast.dat"));
    //INCLUDE LENGTH AND HEIGHT AS INPUT PARAMS
    int startR = 0; int startC = 0;int endR = 0; int endC = 0;
    boolean[][] wasHere = new boolean[10][10];
    boolean[][] correctPath = new boolean[10][10];
    char[][] maze = new char[10][10];
    for (int x = 0; x < 10; x++) {
        char[] curr = scan.nextLine().toCharArray();
        maze[x] = curr;
        for (int i = 0; i < curr.length; i++) {
            if (curr[i] == ('S')) {
                startR = x;
                startC = i;
            } else if (curr[i] == ('E')) {
                endR = x;
                endC = i;
            }
        }
    }

    int energy = scan.nextInt();
    if(ASCII_MAZE_SOLVE(startR, startC, endR, endC, maze, wasHere, correctPath, energy))
        System.out.println("Escaped!");
    else
        System.out.println("Impossible!");
}

public static boolean ASCII_MAZE_SOLVE(int sx, int sy, int ex, int ey, char[][] maze, boolean[][] visited, boolean[][] correct, int energy) {
    if (sx == ex && sy == ey && energy >= 0) return true;
    if (maze[sx][sy] == 'X' || visited[sx][sy] || energy <= 0) return false;
    visited[sx][sy] = true;

    if (maze[sx][sy] == '.') energy--;
    if (maze[sx][sy] == '*') energy-=5;
    if (sx != 0)
        if (ASCII_MAZE_SOLVE(sx - 1, sy, ex, ey, maze, visited, correct, energy)) {
            correct[sx][sy] = true;
            return true;
        }
    if (sx != maze[0].length - 1)
        if (ASCII_MAZE_SOLVE(sx + 1, sy, ex, ey, maze, visited, correct, energy)) {
            correct[sx][sy] = true;
            return true;
        }
    if (sy != 0)
        if (ASCII_MAZE_SOLVE(sx, sy - 1, ex, ey, maze, visited, correct, energy)) {
            correct[sx][sy] = true;
            return true;
        }
    if (sy != maze.length - 1) {
        if (ASCII_MAZE_SOLVE(sx, sy + 1, ex, ey, maze, visited, correct, energy)) {
            correct[sx][sy] = true;
            return true;
        }
    }
    return false;
}